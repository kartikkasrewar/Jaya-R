---
title: "Jaya R Package — Updated Features & Use Cases (with Results)"
author: "Dr. Neeraj D. Bokde"
date: "`r format(Sys.Date())`"
output:
  pdf_document:
    toc: true
    toc_depth: '3'
  html_document:
    toc: true
    toc_depth: 3
    number_sections: true
    df_print: paged
    theme: readable
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(
  echo = TRUE, message = FALSE, warning = FALSE,
  fig.width = 7, fig.height = 4.5, fig.align = "center"
)
```

> This vignette demonstrates the updated **Jaya** functions and **prints results and plots inline**. It sources the stand‑alone R scripts (`jaya.R`, `jaya_multi.R`, `plotting.R`, `summary.R`). When packaged, these functions will be exported and S3 methods registered automatically.

## 1. Prerequisites

```{r}
# install.packages(c("ggplot2", "GGally", "future", "future.apply"), dependencies = TRUE)

source("jaya.R")
source("jaya_multi.R")
source("plotting.R")
source("summary.R")

has_gg <- requireNamespace("ggplot2", quietly = TRUE)
has_ggally <- requireNamespace("GGally", quietly = TRUE)
```

---

## 2. Single‑Objective — Rastrigin (unconstrained) with Plots and Best Solution

```{r}
rastrigin <- function(x) 10*length(x) + sum(x^2 - 10*cos(2*pi*x))

set.seed(42)
fit <- jaya(fun = rastrigin,
            lower = rep(-5.12, 10),
            upper = rep( 5.12, 10),
            popSize = 80, maxiter = 300,
            opt = "minimize",
            verbose = TRUE)

summary(fit)

# Base plot
plot(fit)

# ggplot version (if available)
if (has_gg) {
  p <- autoplot.jaya(fit)
  print(p)
}

# Show best parameters and value
fit$par
fit$value
```

---

## 3. Single‑Objective with Constraints — Reject vs Penalty (Results Shown)

```{r}
sphere <- function(x) sum(x^2)
g1 <- function(x) sum(x) - 2  # <= 0 feasible

# (A) Reject infeasible candidates
set.seed(1)
fit_reject <- jaya(fun = sphere,
                   lower = rep(-1, 5), upper = rep(1, 5),
                   constraints = list(g1),
                   constraint_handling = "reject",
                   popSize = 50, maxiter = 200)
summary(fit_reject)
plot(fit_reject)
if (has_gg) print(autoplot.jaya(fit_reject))

# (B) Penalty for constraint violation
pen <- function(x) 100 * max(0, g1(x))  # linear penalty scaled up
set.seed(1)
fit_penalty <- jaya(fun = function(x) sphere(x) + pen(x),
                    lower = rep(-1, 5), upper = rep(1, 5),
                    popSize = 50, maxiter = 200)
summary(fit_penalty)
plot(fit_penalty)
if (has_gg) print(autoplot.jaya(fit_penalty))
```

---

## 4. Single‑Objective — Parallel Evaluation (Runtime Printed)

```{r}
slow_ackley <- function(x) {
  Sys.sleep(0.002)  # emulate compute
  -20*exp(-0.2*sqrt(mean(x^2))) - exp(mean(cos(2*pi*x))) + 20 + exp(1)
}

fit_par <- jaya(fun = slow_ackley,
                lower = rep(-32.768, 8), upper = rep(32.768, 8),
                popSize = 100, maxiter = 30,
                parallel = TRUE, cores = max(1, parallel::detectCores()-1),
                verbose = TRUE)
summary(fit_par)
plot(fit_par)
if (has_gg) print(autoplot.jaya(fit_par))
```

---

## 5. Single‑Objective — Warm‑Start with Suggestions (Results & Plot)

```{r}
quad <- function(x) sum((x - 0.25)^2)
sug <- matrix(runif(20*5, -1, 1), ncol = 5)  # 20 suggested candidates

fit_ws <- jaya(fun = quad,
               lower = rep(-2, 5), upper = rep(2, 5),
               suggestions = sug,
               popSize = 60, maxiter = 200)
summary(fit_ws)
plot(fit_ws)
if (has_gg) print(autoplot.jaya(fit_ws))
```

---

## 6. Multi‑Objective (2 objectives) — Pareto Front, Plots & Tables

```{r}
f1 <- function(x) sum(x^2)  # Sphere
f2 <- function(x) 10*length(x) + sum(x^2 - 10*cos(2*pi*x))  # Rastrigin

set.seed(7)
mo <- jaya_multi(objectives = list(f1, f2),
                 lower = rep(-5, 3), upper = rep(5, 3),
                 popSize = 120, maxiter = 200,
                 parallel = FALSE)
summary(mo)

# Base Pareto plot
plot(mo)

# ggplot scatter
if (has_gg) print(autoplot.jaya_multi(mo, type = "scatter"))

# Pairs/parallel (if GGally is available); otherwise base pairs
if (has_ggally) {
  print(GGally::ggpairs(mo$Pareto_Front))
} else {
  pairs(mo$Pareto_Front, main = "Pareto Pairs (base)")
}

# Show front / solutions head as a table
if (requireNamespace("knitr", quietly = TRUE)) {
  knitr::kable(head(mo$Pareto_Front), caption = "Pareto Front (head)")
  knitr::kable(head(mo$Solutions), caption = "Solutions (head)")
} else {
  head(mo$Pareto_Front); head(mo$Solutions)
}
```

---

## 7. Multi‑Objective (3 objectives) — ε‑Dominance & Parallel (Archive Size Printed)

```{r}
f1 <- function(x) sum(x^2)
f2 <- function(x) sum((x - 1)^2)
f3 <- function(x) sum((x + 1)^2)

set.seed(99)
mo3 <- jaya_multi(objectives = list(f1, f2, f3),
                  lower = rep(-3, 4), upper = rep(3, 4),
                  popSize = 160, maxiter = 20,
                  archive_size = 120,
                  epsilon = 0.05,      # coarsen grid, sparser set
                  parallel = TRUE, cores = max(1, parallel::detectCores()-1),
                  verbose = TRUE)
summary(mo3)

# Visual (plot first two objectives)
plot(data.frame(Obj1 = mo3$Pareto_Front[,1], Obj2 = mo3$Pareto_Front[,2]),
     xlab = "Obj1", ylab = "Obj2", main = "Pareto (first two objectives)")
if (has_gg) {
  print(ggplot2::ggplot(mo3$Pareto_Front, ggplot2::aes(Obj1, Obj2)) + ggplot2::geom_point() +
          ggplot2::labs(title = "Pareto (first two objectives)"))
}
```

---

## 8. Tidy/Broom‑Style Tables (Printed)

```{r}
# Single-objective tidy
rastrigin <- function(x) 10*length(x) + sum(x^2 - 10*cos(2*pi*x))
sfit <- jaya(rastrigin, rep(-5.12, 5), rep(5.12, 5), popSize = 60, maxiter = 150)

df_tidy <- tidy.jaya(sfit)     # per-iteration best
if (requireNamespace("knitr", quietly = TRUE)) knitr::kable(head(df_tidy), caption = "Per-iteration best (head)") else head(df_tidy)

gl_s <- glance.jaya(sfit)
if (requireNamespace("knitr", quietly = TRUE)) knitr::kable(gl_s, caption = "Glance (single-objective)") else gl_s

# Multi-objective tidy
f1 <- function(x) sum(x^2); f2 <- function(x) sum((x-1)^2)
mfit <- jaya_multi(list(f1, f2), rep(-2, 3), rep(2, 3), popSize = 100, maxiter = 150)

pf  <- tidy.jaya_multi(mfit)   # Pareto front with solution_id
gl  <- glance.jaya_multi(mfit) # archive size, iterations, evals, runtime
if (requireNamespace("knitr", quietly = TRUE)) {
  knitr::kable(head(pf), caption = "Pareto front (head)")
  knitr::kable(gl, caption = "Glance (multi-objective)")
} else {
  head(pf); gl
}
```

---

## 9. Saving Figures (PDF/PNG) and Showing Them Inline

```{r}
ackley <- function(x) -20*exp(-0.2*sqrt(mean(x^2))) - exp(mean(cos(2*pi*x))) + 20 + exp(1)
fit <- jaya(ackley, rep(-32.7, 5), rep(32.7, 5), popSize = 50, maxiter = 200)

# Show inline
plot(fit)
if (has_gg) print(autoplot.jaya(fit))

# Save to files for export
save_plot(function() plot(fit), file = "convergence.pdf", width = 6, height = 4)
if (has_gg) {
  p <- autoplot.jaya(fit)
  save_plot(p, file = "convergence.png", width = 6, height = 4)
}

# Confirm files exist (prints TRUE/FALSE)
file.exists("convergence.pdf")
file.exists("convergence.png")
```

---

## 10. Early Stopping (Printed) + Plot

```{r}
rosenbrock <- function(x) sum(100*(x[-1]-x[-length(x)]^2)^2 + (1 - x[-length(x)])^2)

fit_stop <- jaya(rosenbrock,
                 lower = rep(-2, 6), upper = rep(2, 6),
                 popSize = 80, maxiter = 1000,
                 seed = 123,
                 early_stopping = TRUE, tolerance = 1e-9, patience = 50,
                 verbose = TRUE)
summary(fit_stop)
plot(fit_stop)
if (has_gg) print(autoplot.jaya(fit_stop))
```

---

## 11. Constraint Strategies — Repair vs Reject (Results & Plots)

```{r}
f <- function(x) sum((x - 0.3)^2)
g <- function(x)  sum(x) - 1  # <= 0

fit_repairish <- jaya(f, rep(0, 4), rep(1, 4),
                      constraints = list(g),
                      constraint_handling = "repair",
                      popSize = 50, maxiter = 200)

fit_reject2 <- jaya(f, rep(0, 4), rep(1, 4),
                    constraints = list(g),
                    constraint_handling = "reject",
                    popSize = 50, maxiter = 200)

summary(fit_repairish); summary(fit_reject2)
plot(fit_repairish); plot(fit_reject2)
if (has_gg) { print(autoplot.jaya(fit_repairish)); print(autoplot.jaya(fit_reject2)) }
```

---

## 12. What’s New in This Version (vs 1.0.3)

### Performance
- **Vectorized core updates** for candidate generation and clamping, reducing loops and allocations.
- **Low‑overhead parallelism**: single `future` plan per run with `future.apply` batching (Windows/macOS/Linux).
- **Early stopping**: halts when improvement stays below `tolerance` for `patience` iterations.

### Constraints
- **`constraint_handling` modes**:
  - **`"reject"`** — enforce hard feasibility (resample at init; keep previous solution during search if proposal is infeasible).
  - **`"repair"`** — always repair to box bounds; ready for custom projection hooks.
  - **`"penalty"`** — allow exploration with soft feasibility via `penalty_fun(x)` (default linear penalty).

### Multi‑Objective
- **NSGA‑II–style tools**: fast non‑dominated sorting, crowding distance, and an elitist archive.
- **ε‑dominance (optional)**: thins very large fronts while preserving spread.
- **Normalized guidance** (ideal/nadir) to pick global best/worst exemplars each iteration.

### API & UX
- **Aliases**: `jaya_min()` and `jaya_max()` for explicit intent.
- **Cleaner outputs**: `history`, `best_path`, `n_eval`, `runtime_sec`, and the original `call` for reproducibility.

### Plots & Tables
- **Visuals**: base plots plus `autoplot.jaya()` / `autoplot.jaya_multi()` when **ggplot2** is available.
- **Export**: `save_plot()` for PDF/PNG figures.
- **Reporting**: `summary()`, `tidy()`, `glance()` tables for quick inclusion in reports and pipelines.

---

## 13. Session Info

```{r}
sessionInfo()
```
